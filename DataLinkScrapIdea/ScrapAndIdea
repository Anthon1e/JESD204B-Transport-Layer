`timescale 1ns / 1ps
//////////////////////////////////////////////////////////////////////////////////
// Company: 
// Engineer: 
// 
// Create Date: 06/01/2021 08:12:08 AM
// Design Name: 
// Module Name: jesd204b_dl
// Project Name: 
// Target Devices: 
// Tool Versions: 
// Description: 
// 
// Dependencies: 
// 
// Revision:
// Revision 0.01 - File Created
// Additional Comments:
// 
//////////////////////////////////////////////////////////////////////////////////


module jesd204b_dl #(
    parameter DATA_WIDTH = 16,
    parameter LANES = 2
    )(
    input clk,
    input reset,
    input [DATA_WIDTH-1:0] in,
    output [DATA_WIDTH-1:0] out
    );
    
    localparam LANE_DATA_WIDTH = DATA_WIDTH / LANES;
    
    wire [LANES-1:0] SYNC, LMFC;
    wire [DATA_WIDTH-1:0] out_tx;
    
    reg [LANES-1:0] SYNC_saved;
    always @(*) begin
        if (reset)  SYNC_saved = 'h0;
        else        SYNC_saved = SYNC_saved | SYNC;
    end
    wire all_SYNC = &SYNC_saved;
    
    generate 
    genvar i;
    for (i = 0; i < LANES; i = i + 1) begin
        jesd204b_dl_tx #(
        .DATA_WIDTH (LANE_DATA_WIDTH)
        ) dltx (
        .clk (clk),
        .reset (reset),
        .LMFC (LMFC[i]),
        .SYNC (SYNC[i]), 
        .in (in[i*8+:8]),
        .out (out_tx[i*8+:8])
        );
        
        jesd204b_dl_rx #(
        .DATA_WIDTH (LANE_DATA_WIDTH)
        ) dlrx (
        .clk (clk),
        .reset (reset),
        .LMFC (LMFC[i]), 
        .all_SYNC (all_SYNC),
        .valid (1),
        .in (out_tx[i*8+:8]),
        .out (out[i*8+:8]),
        .SYNC (SYNC[i])
        );
    end
    endgenerate
endmodule


`timescale 1ns / 1ps
//////////////////////////////////////////////////////////////////////////////////
// Company: 
// Engineer: 
// 
// Create Date: 06/01/2021 08:11:22 AM
// Design Name: 
// Module Name: jesd204b_dl_tx
// Project Name: 
// Target Devices: 
// Tool Versions: 
// Description: 
// 
// Dependencies: 
// 
// Revision:
// Revision 0.01 - File Created
// Additional Comments:
// 
//////////////////////////////////////////////////////////////////////////////////


module jesd204b_dl_tx #(
    parameter LANE_DATA_WIDTH = 8,
    parameter OCTETS_PER_FR = 4,
    parameter FRAMES_PER_MF = 8
    )(
    input clk,
    input reset,
    input LMFC,
    input sync_request, 
    input [14*8-1:0] in_config,
    input [LANE_DATA_WIDTH-1:0] in,
    output reg [LANE_DATA_WIDTH-1:0] out,
    output reg ilas_start
    );
    
    localparam OCTETS_PER_MF = OCTETS_PER_FR * FRAMES_PER_MF;
    
    `define RST_T       4'b0000 // Restart state 
    `define CGS_INIT    4'b0001 
    `define CGS_CHECK   4'b0010 
    `define CGS_DATA    4'b0011 
    `define FS_INIT     4'b0100 
    `define FS_DATA     4'b0101 
    `define STATE6      4'b0110 
    `define STATE7      4'b0111 
    `define STATE8      4'b1000 
    `define STATE9      4'b1001 
    
    reg CGS_done = 0;
    reg ILAS_done = 0;
    reg IFS_done = 0;
    
    /* State machine for CGS */
    reg [3:0] cgs_cs, cgs_ns;
    reg [LANE_DATA_WIDTH-1:0] cgs_out;
    always @(posedge clk) begin
        if (reset) begin 
            CGS_done <= 0; 
            cgs_cs <= `RST_T;
            cgs_ns <= `RST_T;
            cgs_out <= 0;
        end else begin 
            case (cgs_cs) 
            `RST_T: begin 
                if (sync_request) 
                    cgs_ns = `CGS_INIT; 
                end
            `CGS_INIT: begin 
                if (~sync_request) begin
                    CGS_done <= 1;
                    cgs_ns = `CGS_INIT; 
                end else begin 
                    cgs_out <= {8'hBC};
                end end
            endcase 
            cgs_cs <= cgs_ns;
        end
    end
    
    /* Elastic buffer to hold data from ADC, waiting for CGS & ILAS */
    reg [7:0] ebuffer [0:255];
    reg [7:0] eindex_in, eindex_out;
    always @(posedge clk) begin
        if (reset) begin
            eindex_in <= 'h0;
        end else begin
            ebuffer[eindex_in] <= in;
            eindex_in <= eindex_in + 1;
        end
    end
    
    /* State machine for ILAS */
    reg [5:0] octet_count, mf_count;
    reg [3:0] config_octet;
    reg ilas_turn;
    reg [LANE_DATA_WIDTH-1:0] ilas_out;
    always @(posedge clk) begin
        if (~CGS_done) begin
            ILAS_done <= 0;
            ilas_turn <= 0;
            ilas_start <= 0;
            octet_count <= 1;
            mf_count <= 1; 
            config_octet <= 0;
        end else begin
            if (LMFC) begin
                ilas_start = 1;
                ilas_turn <= 1; 
            end if (ilas_start) begin 
                // The 2nd frame is for configuration data
                if (mf_count == 'h2) begin
                    // Send R, start of frame
                    if (octet_count == 'h1) begin 
                        ilas_out <= 8'h1c; octet_count <= octet_count + 1; 
                    // Send Q, second char of frame
                    end else if (octet_count == 'h2) begin 
                        ilas_out <= 8'h9c; octet_count <= octet_count + 1; 
                    // Send configuration data
                    end else if (('h2 < octet_count) && (octet_count < 'h10)) begin
                        ilas_out <= in_config[config_octet*8+:8];
                        config_octet <= config_octet + 1;
                        octet_count <= octet_count + 1;
                    // Send A, end of frame
                    end else if (octet_count == OCTETS_PER_MF) begin 
                        ilas_out <= 8'h7c; mf_count <= mf_count + 1; octet_count <= 1;
                    // Send user data otherwise
                    end else begin 
                        ilas_out <= 8'hAA; octet_count <= octet_count + 1; end
                // Rest of frames are the same 
                end else begin 
                    // Send R, start of frame
                    if (octet_count == 'h1) begin 
                        ilas_out <= 8'h1c; octet_count <= octet_count + 1; 
                    // Send A, end of frame
                    end else if (octet_count == OCTETS_PER_MF) begin 
                        ilas_out <= 8'h7c; mf_count <= mf_count + 1; octet_count <= 1;
                        if (mf_count == 'h4) ILAS_done <= 1;
                    // Send user data otherwise
                    end else begin 
                        ilas_out <= 8'hAA; octet_count <= octet_count + 1; end
                end
            end
        end
    end
    
    /* State machine for User Data and Frame/Lane Alignment */
    reg [6:0] octet_count_fr;
    reg [LANE_DATA_WIDTH-1:0] data_prev_AF;
    reg [LANE_DATA_WIDTH-1:0] ud_out;
    reg ud_turn, last_one_replaced;
    always @(posedge clk) begin
        if (~ILAS_done) begin
            ud_turn <= 0;
            ud_out <= 0;
            eindex_out <= 0;
            octet_count_fr <= 0;
            last_one_replaced <= 0;
        end else begin
            ud_turn <= 1;
            // Character replacement for last octet in current frame
            if ((octet_count_fr+1)%OCTETS_PER_FR == 0) begin
                // Case when last octet in current frame equal one of previous frame
                if (data_prev_AF == ebuffer[eindex_out] && ~last_one_replaced) begin
                    // Case when current frame is the end of multiframe
                    if (octet_count_fr == (OCTETS_PER_MF-1)) begin
                        ud_out <= 'h7C;
                        octet_count_fr <= 0;
                    // Remaining cases
                    end else begin
                        ud_out <= 'hFC;
                        octet_count_fr <= octet_count_fr + 1;
                    end
                    last_one_replaced <= 1;
                // Case when it is not equal, or there is an alignment character last time
                end else begin
                    ud_out <= ebuffer[eindex_out];
                    octet_count_fr <= octet_count_fr + 1;
                    last_one_replaced <= 0;
                end
                eindex_out <= eindex_out + 1;
                data_prev_AF <= ebuffer[eindex_out];
            // No character replacement otherwise
            end else begin 
                ud_out <= ebuffer[eindex_out];
                eindex_out <= eindex_out + 1;
                octet_count_fr <= octet_count_fr + 1;
            end
        end
    end
    
    /* Output assignment */
    always @(*) begin
        if (reset) begin
            out = 0;
        end else begin
            if (ud_turn)        out = ud_out;
            else if (ilas_turn) out = ilas_out;
            else                out = cgs_out;
        end
    end
endmodule



`timescale 1ns / 1ps
//////////////////////////////////////////////////////////////////////////////////
// Company: 
// Engineer: 
// 
// Create Date: 06/01/2021 08:12:08 AM
// Design Name: 
// Module Name: jesd204b_dl_rx
// Project Name: 
// Target Devices: 
// Tool Versions: 
// Description: 
// 
// Dependencies: 
// 
// Revision:
// Revision 0.01 - File Created
// Additional Comments:
// 
//////////////////////////////////////////////////////////////////////////////////


module jesd204b_dl_rx #(
    parameter DATA_WIDTH = 8
    )(
    input clk,
    input reset,
    input LMFC, 
    // sync flag for ALL lane when 4 Ks are received
    input all_SYNC,
    // if data is valid based on disparity
    input valid,
    input [DATA_WIDTH-1:0] in,
    output reg [DATA_WIDTH-1:0] out,
    // sync flag of EACH lane when 4 Ks are received
    output reg SYNC
    );
    
    `define RST_T       4'b0000 // Restart state 
    `define CGS_INIT    4'b0001 
    `define CGS_CHECK   4'b0010 
    `define CGS_DATA    4'b0011 
    `define STATE4      4'b0100 
    `define STATE5      4'b0101 
    `define STATE6      4'b0110 
    `define STATE7      4'b0111 
    `define STATE8      4'b1000 
    `define STATE9      4'b1001 
    
    reg [3:0] cs, ns;
    reg [2:0] K_counter, I_counter, V_counter;
        
    always @(posedge clk) begin
        if (reset) begin 
            out <= in;
            SYNC <= 0;
            cs <= `RST_T;
            ns <= `RST_T;
            K_counter <= 0;
        end else begin 
            case (cs) 
            // State after resetted
            `RST_T: begin 
                SYNC <= 0; 
                ns = `CGS_INIT; 
                end
            // State for code group synchronization
            `CGS_INIT: begin 
                I_counter <= 0;
                V_counter <= 0;
                if (in == 'hBC && valid) begin
                    K_counter = K_counter + 1;
                    if (K_counter == 'h4) begin
                        ns = `CGS_CHECK;
                        SYNC <= 1;
                    end else
                        ns = `CGS_INIT;
                end else begin 
                    K_counter <= 0;
                    ns = `CGS_INIT;
                end end     
            // State to check for loss of synchronization
            `CGS_CHECK: begin
                ns = `CGS_CHECK;
                K_counter <= 0;
                if (~valid) begin
                    V_counter <= 0; 
                    I_counter = I_counter + 1;
                    if (I_counter == 'h3) 
                        ns = `CGS_INIT;
                end else begin
                    I_counter <= 0; 
                    V_counter = V_counter + 1;
                    if (I_counter == 'h4)
                        ns = `CGS_DATA;
                end end
            endcase 
            cs <= ns;
        end
    end
    
    reg [7:0] ebuffer [0:63];
    reg [6:0] eindex_in, eindex_out;
    
    always @(posedge clk) begin
        if (reset) begin
            eindex_in <= 'h0;
            eindex_out <= 'h0;
            out <= in;
        end else begin
            if (SYNC == 1) begin
                ebuffer[eindex_in] = in;
                eindex_in <= eindex_in + 1;
                if (all_SYNC == 1) begin 
                    out = ebuffer[eindex_out];
                    eindex_out <= eindex_out + 1;
                end
            end else out <= in;
        end
    end
endmodule


`timescale 1ns / 1ps
//////////////////////////////////////////////////////////////////////////////////
// Company: 
// Engineer: 
// 
// Create Date: 06/01/2021 10:15:07 AM
// Design Name: 
// Module Name: jesd204b_dl_tb
// Project Name: 
// Target Devices: 
// Tool Versions: 
// Description: 
// 
// Dependencies: 
// 
// Revision:
// Revision 0.01 - File Created
// Additional Comments:
// 
//////////////////////////////////////////////////////////////////////////////////


module jesd204b_dl_tb #(
    parameter DATA_WIDTH = 16
    );
    
    reg clock, reset;
    reg [DATA_WIDTH-1:0] in;
    wire [DATA_WIDTH-1:0] out;
    
    jesd204b_dl #(
    .DATA_WIDTH (DATA_WIDTH)
    ) dut (
    .clk (clock),
    .reset (reset),
    .in (in),
    .out (out)
    );
    
    initial begin
        // Set up for the rise of clock every 2 seconds
        clock <= 1'b1;
        #1;
        forever begin
            clock <= 1'b0;
            #1;
            clock <= 1'b1;
            #1;
        end
    end
    
    initial begin 
        reset <= 1; 
        #2; 
        reset <= 0;
        in <= 'h30BC;
        #6; 
        in <= 'h0402;
        #2;
        in <= 'hBCBC;
        #2; 
        in <= 'hBC28;
        #2;
        in <= 'hBCBC;
        #2;
        in <= 'hBCBC;
        #2;
        in <= 'h15BC;
        #2;
        in <= 'h11BC;
        #2; 
        in <= 'hAABB;
        #2;
        in <= 'h2802;
        #6;
        $stop;
    end
endmodule
